# Hash map
## 705_Design_HashSet
使用$hash\_key = key \% size$作为哈希函数，以链表作为容器。
使用质数作为 size 是一个明智的选择。例如769，可以减少潜在的碰撞。
K为桶数量，N为插入的元素数量。
时间复杂度:$O(N/K)$。
* 假设值是平均分布的，因此可以考虑桶的平均大小是$N/K$
* 对于每个操作，在最坏的情况下，我们需要扫描整个桶。

空间复杂度：O(K+N)。

单个容器中的元素较多时，还可以使用二叉搜索树作为容器。时间复杂度可以降为$O(log(N/K))$。

## 706_Design_HashMap
和设计set一样，不过储存的对象是```pair(key, value)```。
注意可以通过指针运算符(->)来操作迭代器，改变value的值。
时间复杂度:$O(N/K)$。
* 假设值是平均分布的，因此可以考虑桶的平均大小是$N/K$
* 对于每个操作，在最坏的情况下，我们需要扫描整个桶。

空间复杂度：O(K+N)。

## 136_Single_Number_01 哈希映射
除了一个元素出现一次，其他的都出现两次。那么如果第一次存入set，第二次删除它，最终set中的那个元素就是只出现了一次的元素。
时间复杂度：O(n)。遍历数组，每次查找、添加或者删除的复杂度为O(1)，总共是O(n)。
空间复杂度：最好O(1)，相同的元素挨在一起；最坏O((n-1)/2))，不同的元素挨在一起。

## 136_Single_Number_02 异或算法
上一题的空间复杂度不满足要求。这里很巧妙的使用了异或的几个特性：
$$a \oplus b = b \oplus a \\ a \oplus a = 0 \\a \oplus 0 = a$$
所以我们遍历数组，做异或运算，相同的两个数字异或会抵消为0，最终结果就是只出现一次的数字。
时间复杂度:O(n)。
空间复杂度:O(1)。



