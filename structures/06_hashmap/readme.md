# Hash map
## 705_Design_HashSet
使用$hash\_key = key \% size$作为哈希函数，以链表作为容器。
使用质数作为 size 是一个明智的选择。例如769，可以减少潜在的碰撞。
K为桶数量，N为插入的元素数量。
时间复杂度:$O(N/K)$。
* 假设值是平均分布的，因此可以考虑桶的平均大小是$N/K$
* 对于每个操作，在最坏的情况下，我们需要扫描整个桶。

空间复杂度：O(K+N)。

单个容器中的元素较多时，还可以使用二叉搜索树作为容器。时间复杂度可以降为$O(log(N/K))$。

## 706_Design_HashMap
和设计set一样，不过储存的对象是```pair(key, value)```。
注意可以通过指针运算符(->)来操作迭代器，改变value的值。
时间复杂度:$O(N/K)$。
* 假设值是平均分布的，因此可以考虑桶的平均大小是$N/K$
* 对于每个操作，在最坏的情况下，我们需要扫描整个桶。

空间复杂度：O(K+N)。

## 136_Single_Number



