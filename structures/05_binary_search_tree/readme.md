# 二叉搜索树

## 98_Validate_Binary_Search_Tree_01 递归
二叉搜索树的特点是：**如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。**
换句话说，左子树的所有值，范围在$[lower, root.val]$；右子树的所有值，范围在$[root.val, upper]$。
如果节点的值val不在$[l,r]$的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。

## 98_Validate_Binary_Search_Tree_02 递归 + 迭代遍历
二叉搜索树的中序遍历为一升序数组，因此我们可以递归得到其中序遍历结果，再遍历一次数组，判断是否为升序。但是这样就相当于遍历了两次，时间复杂度是$O(2n)$，空间复杂度是$O(n)$。

## 98_Validate_Binary_Search_Tree_03 迭代
其实就是在迭代中序遍历的过程中，比较当前节点和上一节点的值，如果```cur->val <= last_val```，则直接返回。这样只需要遍历一次，时间复杂度和空间复杂度都是$O(n)$。

## 173_Binary_Search_Tree_Iterator_01 受控遍历（递归）
其实一个next()过程，就是把当前最小的元素拿出来，再把接下来最小的元素放进去等待下次调用。那么用一个stack来进行中序遍历，每次把左子树循环放进栈，就能保证拿出来的是最小的。拿出来之后，如果没有右子树，那么下次栈顶的元素就是最小的；有右子树，就再把右节点的左子树循环入栈，下次栈顶的元素也是最小的。
均摊时间复杂度为O(1);平均空间复杂度为$O(h) = O(logn)$，最坏为O(n)。

## 173_Binary_Search_Tree_Iterator_01 遍历得升序数组
从得到的升序数组中取最小next()和has_next()的时间复杂度都是O(1)，但是空间复杂度就是O(n)，不满足要求。

# 二叉搜索树的基本操作

## 查找

## 700_Search_in_a_Binary_Search_Tree_01 递归
相等返回；比目标大在左子树找，否则在右子树找。时间复杂度$O(logn)$,空间复杂度$O(h) = O(logn)$，最坏为O(n)。

## 700_Search_in_a_Binary_Search_Tree_01 迭代
相等返回；比目标大在左子树找，否则在右子树找。时间复杂度$O(logn)$，最坏为O(n);空间复杂度O(1)。

## 插入

## 701_Insert_into_a_Binary_Search_Tree_01 递归
比目标大，直接插入左子树；比目标小同理，否则在右子树找。时间复杂度$O(logn)$，最坏为O(n);空间复杂度O(H)。

## 701_Insert_into_a_Binary_Search_Tree_02 迭代
比目标大，如果左子树为空，直接插入，否则在左子树找；比目标小同理，否则在右子树找。时间复杂度$O(logn)$，最坏为O(n);空间复杂度O(1)。

## 删除
删除操作就比较复杂需要分三种情况来处理：

* 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。

* 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。

* 第三种情况是，如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。
## 450_Delete_Node_in_a_BST_01 迭代
使用查找的方法，先找到目标节点，再依据上面的对应策略进行处理。需要注意，删除最小节点时，因为其肯定没有两个节点，则可以使用其他两个情况的逻辑进行处理。时间复杂度$O(h)$，空间复杂度O(1)。

## 450_Delete_Node_in_a_BST_02 递归
在这里，使用递归的方式代替查找操作。
右子树中找最小节点，明确为找后继结点：往右一步，一直向左；
左子树找最大节点，明确为找前驱节点：往左一步，一直往右；
时间复杂度O(h)，空间复杂度O(h)。
具体见二叉搜索树笔记。

# 二叉树的总结：
## 有序地存储数据或者需要同时执行搜索、插入、删除等多步操作

## 703_Kth_Largest_Element_in_a_Stream
在构建树的时候，放置一个计数器count保存以该节点为根节点的树的节点个数，那么，**对于二叉搜索树的每个节点来说，若其左子树共有m个节点，那么该节点是组成二叉搜索树的有序数组中第m + 1个值。** 这样就可以根据需要寻找的idx和当前节点所处位置，进行递归查找。
构造树的时间复杂度为$O(nlogn)$，空间复杂度O(n)。
查找的平均时间复杂度为$O(logn)$,最坏为O(n)；空间复杂度O(1)。

## 235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree_01 递归
和二叉树的公共祖先思路一致，这个因为有序，更简单。根节点在两值之间（闭区间），则两节点就分别在它的左右子树上，root就是祖先；否则根据大小关系，在左子树或右子树中递归查找。
时间复杂度$O(logn)$，最坏为O(n)，空间复杂度$O(1)$。

## 235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree_02 迭代
把递归中的递归查找变为root的手动指定+循环查找。
时间复杂度$O(logn)$，最坏为O(n)，空间复杂度$O(1)$。

## 220_Contains_Duplicate_III_01 暴力解法
要满足题意，我们只需要一个长度为k的滑动窗口，检查其中的元素是否满足要求；但是由于窗口里的元素是无序的，所以每次必须全部遍历一次才能知道是否存在满足要求的元素。
这样的方法时间复杂度过高，是$O(n*min(k,n))$，空间复杂度是$O(1)$,不过提供了一个思路。

## 220_Contains_Duplicate_III_02 平衡二叉搜索树
我们需要在较小的时间复杂度内：
* 元素随时都是有序的；
* 查找符合要求的元素；
* 插入下一个元素；
* 删除第一个元素（窗口个数大于k时）。
显然，二叉搜索树是满足这些要求的。STL中，set的实现是基于**高度平衡的二叉搜索树**的，因此可以使用一个set来完成任务。
我们把大于等于x的最小的数s当做x在BST中的后继节点。同样的，我们把小于等于x最大的数g当做x在BST中的前继节点。s和g这两个数是距离x最近的数。因此只需要检查它们和x的距离就能知道条件是否满足了。
时间复杂度$O(h) = O(log_2min(k,n))$，空间复杂度$O(min(k,n))$。

## 110_Balanced_Binary_Tree_01 自底向上 递归
从底向上解决问题：如果子树不平衡，当前树也不平衡。
所以从叶节点开始向上，如果左右都平衡，则返回其高度$max(left, right)+1$；否则返回-1，代表此树不平衡。最终判断根节点的高度是否为-1。
时间复杂度O(n)，最多需要访问n个节点；
空间复杂度最坏O(n)，退化为链表时，递归栈深度为n。

## 110_Balanced_Binary_Tree_02 自顶向下 递归
从上开始，通过比较根节点左右子树的高度，判断高度差是否满足；满足则递归比较其左右子树，否则返回false。
由于存在大量重复计算，最差情况下（为“满二叉树”时），isBalanced(root) 判断每个节点的深度depth(root)需要遍历各子树的所有节点 。
各层执行depth(root)的时间复杂度为 O(N)（每层开始，最多遍历N个节点，最少遍历$\frac{N+1}{2} $

因此，总体时间复杂度 = 每层执行复杂度× 层数复杂度 = $O(N×logN)$。
空间复杂度为O(n),最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。

## 110_Balanced_Binary_Tree_02 自顶向下 递归+储存
自己的想法是既然存在重复计算，那就用一个map遍历一次，就存储下所有节点的高度信息。比较的时候直接在map当中取就是了。
但是没意义，时间复杂度反而高了，因为本来递归一次就能解决问题，现在递归一次还要去查找。
时间复杂度$O(nlogn + nlogn)$，空间复杂度O(2N)。

## 108_Convert_Sorted_Array_to_Binary_Search_Tree 
此题和**105_Construct_Binary_Tree_from_Preorder_and_Inorder_Traversal**思想是一样的：确定根节点，确定左右子树范围，递归生成。此题可以生成多种结构。
时间复杂度O(n)，每个数访问一次；
空间复杂度：O(logn)，其中n是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是O(logn)。
