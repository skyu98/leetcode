# 二叉搜索树

## 98_Validate_Binary_Search_Tree_01 递归
二叉搜索树的特点是：**如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。**
换句话说，左子树的所有值，范围在$[lower, root.val]$；右子树的所有值，范围在$[root.val, upper]$。
如果节点的值val不在$[l,r]$的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。

## 98_Validate_Binary_Search_Tree_02 递归 + 迭代遍历
二叉搜索树的中序遍历为一升序数组，因此我们可以递归得到其中序遍历结果，再遍历一次数组，判断是否为升序。但是这样就相当于遍历了两次，时间复杂度和空间复杂度都是$O(2n)$。

## 98_Validate_Binary_Search_Tree_03 迭代
其实就是在迭代中序遍历的过程中，比较当前节点和上一节点的值，如果```cur->val <= last_val```，则直接返回。这样只需要遍历一次，时间复杂度和空间复杂度都是$O(n)$。

## 173_Binary_Search_Tree_Iterator_01 受控遍历（递归）
其实一个next()过程，就是把当前最小的元素拿出来，再把接下来最小的元素放进去等待下次调用。那么用一个stack来进行中序遍历，每次把左子树循环放进栈，就能保证拿出来的是最小的。拿出来之后，如果没有右子树，那么下次栈顶的元素就是最小的；有右子树，就再把右节点的左子树循环入栈，下次栈顶的元素也是最小的。
空间复杂度为$O(h) = O(logn)$，均摊时间复杂度为O(1).

## 173_Binary_Search_Tree_Iterator_01 遍历得升序数组
从得到的升序数组中取最小next()和has_next()的时间复杂度都是O(1)，但是空间复杂度就是O(n)，不满足要求。

# 二叉搜索树的基本操作

## 查找

## 700_Search_in_a_Binary_Search_Tree_01 递归
相等返回；比目标大在左子树找，否则在右子树找。空间复杂度O(H)。

## 700_Search_in_a_Binary_Search_Tree_01 迭代
相等返回；比目标大在左子树找，否则在右子树找。空间复杂度O(1)。

## 插入

## 701_Insert_into_a_Binary_Search_Tree_01 递归
比目标大，直接插入左子树；比目标小同理，否则在右子树找。空间复杂度O(H)。

## 701_Insert_into_a_Binary_Search_Tree_02 迭代
比目标大，如果左子树为空，直接插入，否则在左子树找；比目标小同理，否则在右子树找。空间复杂度O(1)。

## 删除
删除操作就比较复杂需要分三种情况来处理：

* 第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为null。

* 第二种情况是，如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。

* 第三种情况是，如果要删除的节点有两个子节点，需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。
## 450_Delete_Node_in_a_BST_01 迭代
使用查找的方法，先找到目标节点，再依据上面的对应策略进行处理。需要注意，删除最小节点时，因为其肯定没有两个节点，则可以使用其他两个情况的逻辑进行处理。

## 450_Delete_Node_in_a_BST_02 递归
在这里，使用递归的方式代替查找操作。
右子树中找最小节点，明确为找后继结点：往右一步，一直向左；
左子树找最大节点，明确为找前驱节点：往左一步，一直往右；
具体见二叉搜索树笔记。

