## Disjointed set 
 	128 	
	130 	
	200 	
	261 	
	305 	
	323 	
	399 	
	547 	
	684 	
	685 	
	721 	
	737 	
	765 	
	778 	
	803 	
	839 	
	924 	
	928 	
	947 	
	952 	
	959 	
	990 	

## 128. Longest Consecutive Sequence 01 Union find simplest 

很明显嵌套肯定不满足O(N)的条件，但是这里主要是熟悉下并查集的模板。如果是能在set里找到num +/- 1(连续)，那么就连接起来，然后每次找到root来更新这个连续数列的个数。

## 200. Number of Islands 03 UNION FIND

## 1202_Smallest_String_With_Swaps
通过并查集找到哪些位置的字母是可以互换的，然后将这些字母和他们的root关联起来，最后重新构造字符串时，每个位置就从root对应的字符集中，取最小的来构造。

时间复杂度：$O((M+N)α(N)+NlogN)$，这里M是数组 pairs 的长度，N 是输入字符串 s 的长度，这里 $α$ 是 Ackermann 函数的反函数（请见参考资料）；

第 1 步：遍历数组 pairs 需要 O(M)，并查集每一次合并（按秩合并）的同时还有路径压缩，时间复杂度为 $O(α(N))$，这一部分总的时间复杂度为 $O(Mα(N))$；

第 2 步：并查集每一次查询的时间复杂度为 $O(α(N))$，一共 N 次查询，时间复杂度为 $O(Nα(N))$，每一个字符加入优先队列。极端情况下，所有字符都在一个优先队列里，每一次调整堆的时间复杂度为 $O(logN)$，这一部分总的时间复杂度为 $O(N(α(N)+logN))$；
第 3 步：极端情况下，所有的字符都在一个连通分量里（所有字符都在一个优先队列里），并查集每一次查询的时间复杂度为 $O(α(N))$，在优先队列里选出字典序最小的字符时间复杂度为 $O(logN)$，一共 N 次调整堆，这一部分总的时间复杂度也为 $O(N(α(N)+logN))$。
空间复杂度：O(N)：并查集的长度为 N ，哈希表的长度为 N，所有的优先队列中加起来一共有 N 个字符，保存结果需要 N 个字符。

