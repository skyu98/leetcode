## Disjointed set 
 	128 	
	130 	
	200 	
	261 	
	305 	
	323 	
	399 	
	547 	
	684 	
	685 	
	721 	
	737 	
	765 	
	778 	
	803 	
	839 	
	924 	
	928 	
	947 	
	952 	
	959 	
	990 	

## 128. Longest Consecutive Sequence 01 Union find simplest 

很明显嵌套肯定不满足O(N)的条件，但是这里主要是熟悉下并查集的模板。如果是能在set里找到num +/- 1(连续)，那么就连接起来，然后每次找到root来更新这个连续数列的个数。

## 200. Number of Islands 03 UNION FIND

## 1202_Smallest_String_With_Swaps
通过并查集找到哪些位置的字母是可以互换的，然后将这些字母和他们的root关联起来，最后重新构造字符串时，每个位置就从root对应的字符集中，取最小的来构造。

时间复杂度：$O((M+N)α(N)+NlogN)$，这里M是数组 pairs 的长度，N 是输入字符串 s 的长度，这里 $α$ 是 Ackermann 函数的反函数（请见参考资料）；

第 1 步：遍历数组 pairs 需要 O(M)，并查集每一次合并（按秩合并）的同时还有路径压缩，时间复杂度为 $O(α(N))$，这一部分总的时间复杂度为 $O(Mα(N))$；

第 2 步：并查集每一次查询的时间复杂度为 $O(α(N))$，一共 N 次查询，时间复杂度为 $O(Nα(N))$，每一个字符加入优先队列。极端情况下，所有字符都在一个优先队列里，每一次调整堆的时间复杂度为 $O(logN)$，这一部分总的时间复杂度为 $O(N(α(N)+logN))$；
第 3 步：极端情况下，所有的字符都在一个连通分量里（所有字符都在一个优先队列里），并查集每一次查询的时间复杂度为 $O(α(N))$，在优先队列里选出字典序最小的字符时间复杂度为 $O(logN)$，一共 N 次调整堆，这一部分总的时间复杂度也为 $O(N(α(N)+logN))$。
空间复杂度：O(N)：并查集的长度为 N ，哈希表的长度为 N，所有的优先队列中加起来一共有 N 个字符，保存结果需要 N 个字符。

## 684_Redundant_Connection
一棵树有N个节点，N-1条边，多的一条边让它有了一个环。
本质是这条边把本来就已经连通的两个节点，再次连接起来，形成了闭环。
那么我们考察每条边，如果它的两个端点没有连通，那么加入这条边没有任何问题，我们将它们连通；如果已经连通，那么这条边就是最后的那条形成闭环的边。

连通 + 判断是否连通 = 并查集

时间复杂度：2N次查询，N次合并。最坏$O(NlogN)$；平均$O(N*\alpha(N))$
空间复杂度：O（N）。储存N个节点。

## 947_Most_Stones_Removed_with_Same_Row_or_Column
原本是打算通过检查有无同行同列，来删除石头，但是显然删除顺序会影响结果。
同属一个连通域的石头可以删除到只剩一个。考虑一个石头的坐标为[i, j]，那么显然：所有横坐标为i和纵坐标为j的石头都被连通了。
由于这里需要计算连通域的个数，所以我们在插入新顶点（之前没有同行同列的石头）时++count；在合并（通过[i, j]将所有横坐标为i和纵坐标为j的石头连通）时--count。

时间复杂度：$O(N\alpha(N))$
空间复杂度：O(N)
