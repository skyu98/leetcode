## Disjointed set 
 	128 	
	130 	
	200 	
	261 	
	305 	
	323 	
	399 	
	547 	
	684 	
	685 	
	721 	
	737 	
	765 	
	778 	
	803 	
	839 	
	924 	
	928 	
	947 	
	952 	
	959 	
	990 	

## 128. Longest Consecutive Sequence 01 Union find simplest 

很明显嵌套肯定不满足O(N)的条件，但是这里主要是熟悉下并查集的模板。如果是能在set里找到num +/- 1(连续)，那么就连接起来，然后每次找到root来更新这个连续数列的个数。

## 200. Number of Islands 03 UNION FIND

## 1202_Smallest_String_With_Swaps
通过并查集找到哪些位置的字母是可以互换的，然后将这些字母和他们的root关联起来，最后重新构造字符串时，每个位置就从root对应的字符集中，取最小的来构造。

时间复杂度：$O((M+N)α(N)+NlogN)$，这里M是数组 pairs 的长度，N 是输入字符串 s 的长度，这里 $α$ 是 Ackermann 函数的反函数（请见参考资料）；

第 1 步：遍历数组 pairs 需要 O(M)，并查集每一次合并（按秩合并）的同时还有路径压缩，时间复杂度为 $O(α(N))$，这一部分总的时间复杂度为 $O(Mα(N))$；

第 2 步：并查集每一次查询的时间复杂度为 $O(α(N))$，一共 N 次查询，时间复杂度为 $O(Nα(N))$，每一个字符加入优先队列。极端情况下，所有字符都在一个优先队列里，每一次调整堆的时间复杂度为 $O(logN)$，这一部分总的时间复杂度为 $O(N(α(N)+logN))$；
第 3 步：极端情况下，所有的字符都在一个连通分量里（所有字符都在一个优先队列里），并查集每一次查询的时间复杂度为 $O(α(N))$，在优先队列里选出字典序最小的字符时间复杂度为 $O(logN)$，一共 N 次调整堆，这一部分总的时间复杂度也为 $O(N(α(N)+logN))$。
空间复杂度：O(N)：并查集的长度为 N ，哈希表的长度为 N，所有的优先队列中加起来一共有 N 个字符，保存结果需要 N 个字符。

## 684_Redundant_Connection
一棵树有N个节点，N-1条边，多的一条边让它有了一个环。
本质是这条边把本来就已经连通的两个节点，再次连接起来，形成了闭环。
那么我们考察每条边，如果它的两个端点没有连通，那么加入这条边没有任何问题，我们将它们连通；如果已经连通，那么这条边就是最后的那条形成闭环的边。

连通 + 判断是否连通 = 并查集

时间复杂度：2N次查询，N次合并。最坏$O(NlogN)$；平均$O(N*\alpha(N))$
空间复杂度：O（N）。储存N个节点。

## 947_Most_Stones_Removed_with_Same_Row_or_Column
原本是打算通过检查有无同行同列，来删除石头，但是显然删除顺序会影响结果。
同属一个连通域的石头可以删除到只剩一个。考虑一个石头的坐标为[i, j]，那么显然：所有横坐标为i和纵坐标为j的石头都被连通了。
由于这里需要计算连通域的个数，所以我们在插入新顶点（之前没有同行同列的石头）时++count；在合并（通过[i, j]将所有横坐标为i和纵坐标为j的石头连通）时--count。

时间复杂度：$O(N\alpha(N))$
空间复杂度：O(N)

## 1584_Min_Cost_to_Connect_All_Points
(lambda函数的使用很方便)
考虑到是贪心算法 + 并查集，但没有想到是一开始将所有的边都记录下来，并且记录的是两端和边长；

* 1.遍历并记录下所有边，按边长排序
* 2.从而通过看两端点是否连通，来决定是否采用这条边
* 3.当采用了n条边，就说明最小树建立完成

时间复杂度：$O(n^2\log(n))$,其中 n 是节点数。一般 Kruskal 是 $O(m\log m)$ 的算法（带排序），但本题中 $m=n^2$，因此总时间复杂度为 $O(n^2\log(n))$。

空间复杂度：$O(n^2)$.其中 n 是节点数。并查集使用 O(n) 的空间，边集数组需要使用$ O(n^2) $的空间。

## 1489_Find_Critical_and_Pseudo-Critical_Edges_in_Minimum_Spanning_Tree
重点在于理解什么是关键边，什么是非关键边；

* 关键边：如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。也就是说，如果设原图最小生成树的权值为 \textit{value}value，那么去掉这条边后：

	* 要么整个图不连通，不存在最小生成树；

	* 要么整个图联通，对应的最小生成树的权值为 vv，其严格大于 \textit{value}value。

* 伪关键边：可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。也就是说，我们可以在计算最小生成树的过程中，最先考虑这条边，即最先将这条边的两个端点在并查集中合并。设最终得到的最小生成树权值为 vv，如果 v = \textit{value}v=value，那么这条边就是伪关键边。

需要注意的是，关键边也满足伪关键边对应的性质。因此，我们首先对原图执行 Kruskal 算法，得到最小生成树的权值 value，随后我们枚举每一条边，首先根据上面的方法判断其是否是关键边，如果不是关键边，再判断其是否是伪关键边。

这里将Kruskal 算法封装了一下，通过输入参数来进行任务调整。

时间复杂度：排序O(mlogm),最多进行2m次Kruskal 算法（不带排序），最坏为$O(2m*m*\alpha(n)) = O(m^2)$

空间复杂度：O（m+n）；m是idx信息，n是并查集
