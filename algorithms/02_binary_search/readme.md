# 二分查找

## 核心思想：通过nums[mid]和target之间的关系，来确定target所在区间。

## 704_Binary_Search_01 迭代
最基础的二分查找。
时间复杂度O(logN)，空间复杂度O(1)。

## 704_Binary_Search_02 递归
换个写法。
时间复杂度O(logN)，空间复杂度O(1)。

## 69_Sqrt(x)
判断条件改变：```if(mid*mid == x)```。重点是在于精确度的处理。
时间复杂度O(logX)， 空间复杂度O(1)。

## 374_Guess_Number_Higher_or_Lower_01 二分查找
和最基础的一样，用接口来判断而已。
时间复杂度O(logN)，空间复杂度O(1)。

## 374_Guess_Number_Higher_or_Lower_02 三分查找
思想和二分查找一样，通过比较分界点来判断区间。
时间复杂度$O(log_3N)$，空间复杂度O(1)。
**为什么三分查找复杂度更低，但是更经常用二分查找？**
最坏情况下三分查找比较次数比二分查找最坏情况要多。

## 33_Search_in_Rotated_Sorted_Array
这种情况虽然复杂一点，但是核心思想没有变：**通过nums[mid]和target之间的关系，来确定target所在区间。**
只是要特别注意，还要通过比较nums[mid]和边界值，来确定target是否和mid在同一有序区间。
时间复杂度O(logN)，空间复杂度O(1)。

## 278_First_Bad_Version
此题本质是找第一个等于指定元素（第一个为true）的元素，因此我们在每次找到等于之后，还要检查其前一个元素是否等于，或者该元素是不是第一个。（leetcode的模板过于简洁，难以理解。使用的模板见二分算法学习笔记。）
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_01 翻译想法
就是把自己的想法翻译出来——峰值的左右比它本身小。这导致判断条件及其复杂。
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_02 巧妙判断——迭代
其实要找峰值，只需要确定一个方向。mid的左边的mid大，那有一个峰值就在mid左边；右边同理。
所以我们不断地从两边逼近去找峰值，当区间里只有一个元素，它自然就是峰值（判断条件就是```low==high```）。
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_03 巧妙判断——递归
思想和上一种一样，换个写法。
时间复杂度O(logN)，空间复杂度O(logN)——**这里是尾递归，个人觉得空间复杂度为O(1)**。

## 153_Find_Minimum_in_Rotated_Sorted_Array
这道题很好的说明了和不同的边界值对比所带来的结果完全不同。
用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。

左、中、右三个位置的值相比较，有以下几种情况：

左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界

            右
        中
     左

左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界

    左       
            右
        中

左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界

         中  
    左 
             右

左值 > 中值, 中值 > 右值 ：单调递减，不可能出现

    左
        中
            右

分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。

如果中值 < 右值，则最小值在左半边，可以收缩右边界。
如果中值 > 右值，则最小值在右半边，可以收缩左边界。
通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。

而情况1与情况3都是左值 < 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。

所以我们需要通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。
时间复杂度O(logN)，空间复杂度O(1)。

## 34_Find_First_and_Last_Position_of_Element in_Sorted_Array

此题其实就是找第一个和最后一个等于目标的元素。所以每次找到等于目标的元素时，要判断其前面或者后面的元素，以此来确实是否找到。
leetcode的题解简洁，但是很不好理解，并且思想一样，为了避免混淆，这里就不记录了。
时间复杂度O(2logN)=O(logN)，空间复杂度O(1)。

## 367_Valid_Perfect_Square 
此题就是在升序数组里找符合要求的元素，只是比较它的平方值。
时间复杂度O(log(num/2-2)) = O(log(num))， 空间复杂度O(1)

## 744_Find_Smallest_Letter_Greater_Than_Target
因为char可以直接比较大小，所以此题就是寻找第一个大于指定元素的元素。
时间复杂度O(logn)，空间复杂度O(1)。

## 154_Find_Minimum_in_Rotated_Sorted_Array_II
这道题和153的思想很像，但是因为有重复元素，所以有相等的情况，在比较上造成了麻烦：
如果中值 < 右值，则最小值在左半边，可以收缩右边界。
如果中值 > 右值，则最小值在右半边，可以收缩左边界。
如果中值 == 右值，由于有重复元素，我们难以确定mid在最小值的哪边，如图：
![equal](./154_Find_Minimum_in_Rotated_Sorted_Array_II/mid_equals_high.png)
因为中值等于右值，唯一可以知道的是，由于它们的值相同，所以无论nums[high] 是不是最小值，都有一个它的「替代品」nums[mid]，因此我们可以忽略二分查找区间的右端点。
(**舍弃一个端点，也是在缩小区间**)

## 349_Intersection_of_Two_Arrays_01 二分查找
没想到就是排序之后，遍历一个数组，在另一个中去二分查找。虽然有点牵强，但是这样的思想之后有可能可以借鉴。
* 时间复杂度：sort()使用的是类似于快速排序的方法，因此排序的时间复杂度为$O(nlogn+ mlogm)$；最坏的情况下，数组里每个元素都不一样，因此时间复杂度为O(nlogm)（假设遍历的数组有n个元素）。假设两个数组的长度差距不大，总的时间复杂度是O(nlogn)。
* 空间复杂度O(1)。排序是原地排序，查找也未使用额外空间。

## 349_Intersection_of_Two_Arrays_02 set
思路：
1.用两个set容器，第一set是遍历nums1，去重
2.第二个set是去查验保存结果，若存在则插入。
时间复杂度最坏O(n)，空间复杂度O(n)。

## 350_Intersection_of_Two_Arrays_II_01 二分查找
此题思路和349一样，不过需要考虑每个元素出现的次数。
思路是，每次在两个数组中找到同一个元素，记录并剔除两者。因此有三个点需要注意：
1.遍历的数组中，相同的元素不能跳过。第一个该元素没有找到，下一个相同的元素可以不再找；但找到了，下一个元素还需要在剔除了的数组里面继续二分查找；
2.二分查找的目标是第一个大于等于目标元素的元素。我们要保证被查找的元素在左边没有遗漏；
2.第二次查找的左界。如果找到的结果nums2[mid]如果是大于目标元素，那么第二次就以该元素为左边界；如果找到的结果nums2[mid]如果是等于目标元素，那么就记录下来，并且第二次就以该元素的下一个元素为左边界（该元素被剔除）。
* 时间复杂度：和上题类似，假设两个数组的长度差距不大，总的时间复杂度是O(nlogn)。
* 空间复杂度O(1)。排序是原地排序，查找也未使用额外空间。

## 350_Intersection_of_Two_Arrays_II_02 双指针
首先对两个数组进行排序。
初始时，两个指针分别指向两个数组的头部。每次比较两个指针指向的两个数组中的数字，如果两个数字不相等，则将指向较小数字的指针右移一位，如果两个数字相等，将该数字添加到答案，并将两个指针都右移一位。当至少有一个指针超出数组范围时，遍历结束。

* 时间复杂度：$O(mlogm+nlogn)$，其中m和n分别是两个数组的长度。对两个数组进行排序的时间复杂度是$O(mlogm+nlogn)$，遍历两个数组的时间复杂度是O(m+n)，因此总时间复杂度是$O(mlogm+nlogn)$。

* 空间复杂度：在 C++ 中，直接创建一个 vector，不需要把答案临时存放在一个额外的数组中，所以这种实现的空间复杂度为O(1)。

## 350_Intersection_of_Two_Arrays_II_03 hash_map
首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数，然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案，并减少哈希表中该数字出现的次数，当次数为0时便剔除高该数字。

* 时间复杂度：O(m+n)，其中m和n分别是两个数组的长度。需要遍历两个数组并对哈希表进行操作，哈希表操作的时间复杂度是O(1)，因此总时间复杂度与两个数组的长度和呈线性关系。

* 空间复杂度：在 C++ 中，直接创建一个 vector，不需要把答案临时存放在一个额外的数组中，所以这种实现的空间复杂度为O(1)。

## 167_Two_Sum_II_Input_array_is_sorted_01 二分查找
遍历数组，每次确定第一个数，在数组中去二分查找第二个数。
* 时间复杂度：最坏情况：$O(log(n-1) + log(n-2) +...+ log(1)) = O(nlogn)$  
* 空间复杂度：O(1)。

## 167_Two_Sum_II_Input_array_is_sorted_02 双指针
初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。

* 时间复杂度：O(n)。两个指针移动的总次数最多为 n 次。

* 空间复杂度：O(1)。