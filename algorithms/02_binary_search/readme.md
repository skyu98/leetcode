# 二分查找

## 核心思想：通过nums[mid]和target之间的关系，来确定target所在区间。

## 704_Binary_Search_01 迭代
最基础的二分查找。
时间复杂度O(logN)，空间复杂度O(1)。

## 704_Binary_Search_02 递归
换个写法。
时间复杂度O(logN)，空间复杂度O(1)。

## 69_Sqrt(x)
判断条件改变：```if(mid*mid == x)```。重点是在于精确度的处理。
时间复杂度O(logX)， 空间复杂度O(1)。

## 374_Guess_Number_Higher_or_Lower_01 二分查找
和最基础的一样，用接口来判断而已。
时间复杂度O(logN)，空间复杂度O(1)。

## 374_Guess_Number_Higher_or_Lower_02 三分查找
思想和二分查找一样，通过比较分界点来判断区间。
时间复杂度$O(log_3N)$，空间复杂度O(1)。
**为什么三分查找复杂度更低，但是更经常用二分查找？**
最坏情况下三分查找比较次数比二分查找最坏情况要多。

## 33_Search_in_Rotated_Sorted_Array
这种情况虽然复杂一点，但是核心思想没有变：**通过nums[mid]和target之间的关系，来确定target所在区间。**
只是要特别注意，还要通过比较nums[mid]和边界值，来确定target是否和mid在同一有序区间。
时间复杂度O(logN)，空间复杂度O(1)。

## 278_First_Bad_Version
此题本质是找第一个等于指定元素（第一个为true）的元素，因此我们在每次找到等于之后，还要检查其前一个元素是否等于，或者该元素是不是第一个。（leetcode的模板过于简洁，难以理解。使用的模板见二分算法学习笔记。）
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_01 翻译想法
就是把自己的想法翻译出来——峰值的左右比它本身小。这导致判断条件及其复杂。
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_02 巧妙判断——迭代
其实要找峰值，只需要确定一个方向。mid的左边的mid大，那有一个峰值就在mid左边；右边同理。
所以我们不断地从两边逼近去找峰值，当区间里只有一个元素，它自然就是峰值（判断条件就是```low==high```）。
时间复杂度O(logN)，空间复杂度O(1)。

## 162_Find_Peak_Element_03 巧妙判断——递归
思想和上一种一样，换个写法。
时间复杂度O(logN)，空间复杂度O(logN)——**这里是尾递归，个人觉得空间复杂度为O(1)**。

## 153_Find_Minimum_in_Rotated_Sorted_Array
这道题很好的说明了和不同的边界值对比所带来的结果完全不同。
用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界。

左、中、右三个位置的值相比较，有以下几种情况：

左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界

            右
        中
     左

左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界

    左       
            右
        中

左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界

         中  
    左 
             右

左值 > 中值, 中值 > 右值 ：单调递减，不可能出现

    左
        中
            右

分析前面三种可能的情况，会发现情况1、2是一类，情况3是另一类。

如果中值 < 右值，则最小值在左半边，可以收缩右边界。
如果中值 > 右值，则最小值在右半边，可以收缩左边界。
通过比较中值与右值，可以确定最小值的位置范围，从而决定边界收缩的方向。

而情况1与情况3都是左值 < 中值，但是最小值位置范围却不同，这说明，如果只比较左值与中值，不能确定最小值的位置范围。

所以我们需要通过比较中值与右值来确定最小值的位置范围，进而确定边界收缩的方向。
时间复杂度O(logN)，空间复杂度O(1)。

## 34_Find_First_and_Last_Position_of_Element in_Sorted_Array

此题其实就是找第一个和最后一个等于目标的元素。所以每次找到等于目标的元素时，要判断其前面或者后面的元素，以此来确实是否找到。
leetcode的题解简洁，但是很不好理解，并且思想一样，为了避免混淆，这里就不记录了。
时间复杂度O(2logN)=O(logN)，空间复杂度O(1)。

## 367_Valid_Perfect_Square 
此题就是在升序数组里找符合要求的元素，只是比较它的平方值。
时间复杂度O(log(num/2-2)) = O(log(num))， 空间复杂度O(1)

## 744_Find_Smallest_Letter_Greater_Than_Target
因为char可以直接比较大小，所以此题就是寻找第一个大于指定元素的元素。
时间复杂度O(logn)，空间复杂度O(1)。

## 154_Find_Minimum_in_Rotated_Sorted_Array_II
这道题和153的思想很像，但是因为有重复元素，所以有相等的情况，在比较上造成了麻烦：
如果中值 < 右值，则最小值在左半边，可以收缩右边界。
如果中值 > 右值，则最小值在右半边，可以收缩左边界。
如果中值 == 右值，由于有重复元素，我们难以确定mid在最小值的哪边，如图：
![equal](./154_Find_Minimum_in_Rotated_Sorted_Array_II/mid_equals_high.png)
因为中值等于右值，唯一可以知道的是，由于它们的值相同，所以无论nums[high] 是不是最小值，都有一个它的「替代品」nums[mid]，因此我们可以忽略二分查找区间的右端点。
(**舍弃一个端点，也是在缩小区间**)