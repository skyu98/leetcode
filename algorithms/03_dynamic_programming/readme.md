# 动态规划

## 121_Best_Time_to_Buy_and_Sell_Stock
此题想先用```dp[i][j]```表示第i天买入第j天卖出的利润，但这样并没有找出状态转移方程，本质上就是暴力法。
所以应该用```dp[i]```表示第i天时的最大利润。先只考虑卖出，第i天有两种情况，卖或者不卖，那么：
```cpp
dp[i] = max(dp[i - 1], prices[i] - minPrice);
```
其中，minPrice是前i天的最低价格；所以，我们需要维护一个minPrice变量来保存最小值。 

时间复杂度：O(n)
空间复杂度：O(n)。因为只用到dp[i - 1]，可以优化到O(1)。

## 53_Maximum_Subarray
因为要求是连续子数组，所以状态dp[i]为以**第i个数字结尾的数组的最大子序和**；那么，对于第[i]个数字，我们有两种选择：
1.把它加入到前i-1的子数组;
2.不加入，从自己开始作为一个新的子数组。

显然，我们将选择两者当中更大的那个作为dp[i]。状态转移方程为
```cpp
dp[i] = max(nums[i], dp[i - 1] + nums[i]0);

//base case:
dp[0] = nums[0];
```
最终,$$max_{i \in(0, n-1)}{dp[i]}$$就是所给数组的最大子序和。

时间复杂度：O(n)
空间复杂度：O(n)。因为只用到dp[i - 1]，可以优化到O(1)。

## 198_House_Robber
对于每一间房，我们可以选择抢或者不抢，那么对于第i间房：
1.抢，金额最大是前i-2间房的金额加上nums[i]；
2.不抢，金额为前i-1间房的最大金额。

那么，状态转移方程为：
```cpp
dp[i] = max(dp[i-1], dp[i-2] + nums[i]);

// base case
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
```

时间复杂度：O(n)
空间复杂度：O(n)。因为只用到dp[i-1]和dp[i-2]，可以优化到O(1)。

## 1143_Longest_Common_Subsequence
对于两个字符串的动态规划，一般会以“前i个字符”的状态来推导。
此题中，$dp[i][j]$ 的含义是：
对于 $s1[1..i] 和 s2[1..j]$ ，它们的 LCS ⻓度是$dp[i][j]$。
显然有：
```cpp
 if(text1[i-1] == text2[j-1])
{
    dp[i][j] = dp[i-1][j-1] + 1;
}
else
{
    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
}

// base case
dp[0][...] = 0;
dp[...][0] = 0;
```
时间复杂度：O(m*n)
空间复杂度：O(m*n)。因为只用到相邻的状态，所以可以优化到O(n)。

# 188_Best_Time_to_Buy_and_Sell_Stock_IV
每一天，我们选择买入或者卖出，还要考虑操作的次数。因此每天的状态如下：
```dp[i][j][0]:第i天进行了j次交易，手里没有股票的情况下的最大利润```
```dp[i][j][1]:第i天进行了j次交易，手里有股票的情况下的最大利润```

那么，边界条件可得：
```cpp
dp[0][j][0] = 0;
dp[0][j][1] = -prices[0];
```

那么，第i天的最大利润，就由如下状态转移方程得来：
```cpp
dp[i][j][0] = max(dp[i-1][j][0], dp[i-1][j-1][1] + prices[i]); // 不变或者卖出
dp[i][j][1] = max(dp[i-1][j][1], dp[i-1][j][0] - prices[i]);  // 不变或者买入
```

由于并不是交易次数越多利润越大，而且最终股票卖出的利润肯定最大，所以最终的最大利润就是：
```dp[size][...][0]```中的最大值。

时间复杂度：O(size*k)
空间复杂度：O(size*k)。可以优化到O(k).